### 1.1 Why should you reset the database before each test case? Give examples of issues you may meet otherwise.

If you don't reset the database before each test case, you may end up with data from a previous test case affecting the current one. For example, if you're testing the functionality of a "add to cart" button on an e-commerce site, and the database is not reset before each test, the cart may already have items in it from a previous test, which would affect the current test.

### 1.2 What kind of error is currently thrown in test case "should raise error if email is missing"? Is it an SQL error (occurring in the database server) or a validation error before the query got executed? What should it be, so it is easy and secure to format an error message to the end user (considering security, message internationalization, etc.)?

This a SQL error, because the column “email” is non nullable. We should use server-side validations so it’s easier to parse et format error messages, and we don’t take the risk to leak the database error to the client.

### 1.3 Why do we need both a database constraint and a validation in typescript for the same check?

We use both database constraint and typescript constraint first because it’s a business rules, and business rules should be managed by the business domain, and because it’s easier to manage error messages and internationalization manually in the code.

### 1.4 How models validations, such as the one you just wrote, can serve the security of your application? Give an example. In addition, which database mechanism can be leveraged for security hardening in case a validation fails (ex. while persisting 2 entities in response to the same action)? Clue: the mechanism I am thinking about could also operate on afterUpdate subscriptions.

These model validations make our application more secure because it makes it easier to deal with errors. Database error messages are complicated to work with and susceptible to change (if one of the table or column changes name, type and so on). Thus, needing to parse back the error from the database may break easily. Moreover, letting the database deal with errors opens the possibility of leaking a database stack trace to the API caller, which we must avoid.

If we chain two insertions, updates and so on, we run into the risk of having a valid first query, but an invalid second one. In that case, the system would end up in an invalid state where the first entity has been persisted but not the second one. To prevent this, we can use transactions to make a set of operations atomic : either they all succeed, or they all fail. For instance, in a banking application, if the first operation is to insert a new payment, and the second to update the account total, it would be bad to store the payment, but have a bug in the update of the total that would leave it unchanged. If we use a transaction, a problem in the second update will lead to a rejection of the whole transaction and thus revert the insertion of the payment.

### 2.1 Write a small paper about REST naming convention

REST is all about treating endpoints as resources that are acted on, by opposition to older methods like RPC (Remote Procedure Call) where endpoints would represent functions of the system.

This means that to change the action being performed, one should change the HTTP verb of the request and not the URL. Indeed, URLs represent resources, so different actions on the same resource should happen on the same URL. For instance, if we designed an API the RPC way, we would have routes like `GET /api/get-user?userId={userId}` ; `POST /api/create-user` ; `POST /api/update-user` ; and so on. Instead, designing it in a RESTful way, we would have `GET /api/user/{userId}` ; `POST /api/user` ; `PUT /api/user/{userId}` ; and so on. The URL is constant because we are working on the same resource.

Typically, we use the following mapping for CRUD operations :

| HTTP verb | Action | Detail                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|-----------|--------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| GET       | READ   | Fetch a resource. For instance, `GET /api/products` should return all the products of an e-commerce site, while `GET /api/product/{productId}` would return the details of a specific product.                                                                                                                                                                                                                                                                                                                      |
| POST      | CREATE | Create a new resource. For instance, `POST /api/article/{articleId}/comment` would create a new comment on the article `{articleId}`. Be careful though, requests with this verb are not supposed to be idempotent : calling the api N times will create N comments.                                                                                                                                                                                                                                                |
| PUT       | UPDATE | Replace a resource, in an idempotent way. For instance, `PUT /api/article/{articleId}/comment/{commentId}` would replace the comment `{commentId}` on the article `{articleId}`. However, routes that use this verb are supposed to be idempotent : calling them multiple time (with the same values of course) should produce the same result as calling it once. "Naive" updates where we replace the whole entity are typically implemented with this verb.                                                      |
| PATCH     | UPDATE | Update part of a resource, in an idempotent way. For instance, `PATCH /api/article/{articleId}/comment/{commentId}` would update part of the comment `{commentId}` on the article `{articleId}` (for instance, only the text, or only the rating, or both but not a third value). However, routes that use this verb are supposed to be idempotent : calling them multiple time (with the same values of course) should produce the same result as calling it once. Partial updates are implemented with this verb. |
| DELETE    | DELETE | Delete a resource. For instance, `DELETE /api/video/{videoId}` would remove the video `{videoId}` from the system.                                                                                                                                                                                                                                                                                                                                                                                                  |

Options on the request (for example a search criteria in a GET request) typically use URL parameters (ex: `?searchCriteria=name&name=Foo`). Details about the resource (for example the content of a new article in a POST request) are passed through the request/response body.

It is important to use the right verb for the right action. Otherwise, other developers will be confused about what the route actually does because its naming goes against the common convention.

### 2.2 Considering they use REST naming convention, what would do POST /web-api/users and POST /web-api/sessions endpoints?

`POST /web-api/users` would register a user (create a new user)

`POST /web-api/sessions` would log-in a user (create a new session, which we only do if the user's credentials are valid)

### 2.5 Compare the stateful session persisted in a backend service with a stateless session management like JWT.

| Criteria                           | Stateful session in backend service                                                                                                                                                                     | JWT                                                                                                                                                                                                                                                                                                            |
|------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Scalability                        | Low. Every requests needs to hit a central database which stores all session data. Scale can only be achieved via sharding since we want to prioritize consistency (so NoSQL solutions are suboptimal). | High. Since this solution is stateless, each replica of the server can validate the token independently.                                                                                                                                                                                                       |
| Architecture complexity            | High. The central session service must hydrate other parts of the application / system with the data, and represents a single point of failure                                                          | Mid. The generation service must be hardened enough and have access to all the data stored in the token. It must also expose a public certificate so other parts of the system can validate the signature. However, other services can simply read the data in the token and don't need to wait on a response. |
| Information known by client        | None. The session token is entirely random and means nothing for the client. No information can be extracted from it on the client side.                                                                | Everything. All the data in the token is public and can be access on the client side. It is possible to encrypt the data to mitigate this, but that adds complexity on the server side and kind of defeats the point.                                                                                          |
| Revocation strategy                | Easy. Just remove the entry from the database                                                                                                                                                           | Impossible. In its purely stateless form, there is no way to revoke a JWT before its expiration date.                                                                                                                                                                                                          |
| Impact in case of a session leak   | Low. The user can change their password to reset all sessions.                                                                                                                                          | High. The attacker has access to all the data stored in the token, and there is no way to prevent the attacker from impersonating the user until the token's expiration date.                                                                                                                                  |
| Common misconfiguration weaknesses | Using HTTP instead of HTTPS. Not setting the cookie to HTTP-only. Not setting the cookie to Secure. Not setting the cookie to Same-Site / insufficient CSRF protection. Misconfigured CORS.             | Using HTTP instead of HTTPS. Leaking user data in the token. Leaking the token on the client side (via XSS for instance). Misconfigured CORS.                                                                                                                                                                  |
| Client-side protection strategies  | Set the cookie to Http-only to prevent the JavaScript from accessing it (defend against XSS). Set the cookie to Secure to prevent it from being sent over HTTP. Configure CORS properly.                | No real way to protect it : LocalStorage is vulnerable to XSS, RAM is vulnerable to XSS. Configure CORS properly. Always enforce HTTPS to prevent leaking the token                                                                                                                                            |

### 2.6 Search and summarise solutions to protect the confidentiality of the session identifier stored in a browser’s cookie. Focus on the actions you can take as a backend developer or server-side infrastructure engineer.

The first thing is to do is to use the correct options in the set cookie header :
- `Expires` : Set a cookie's max age according to the balance between security and convenience. A short time when security is of utmost importance (ex: banking), and longer when usability is more of a concern (ex: music or video streaming platform)
- `Domain` : Be careful to use the most restrictive domain possible. For instance, if this cookie should be valid on a subdomain only, you need to be explicit about it.
- `Secure` : Always enable this options, as it will ensure the browser only sends the cookie over HTTPS
- `HttpOnly` : Always enable this options, as it will ensure the browser prevents the frontend JavaScript from accessing the cookie (thus preventing attackers from obtaining it through attacks such as XSS)
- `SameSite` : Be as strict as possible to prevent as many cross site attacks as possible

Then other steps can be taken to avoid usurpation :
- Properly configure HTTPS certificates
- Use HTTP redirections from `http://*` URLs to `https://*` (not sufficient in itself as it is useless against MITM attacks, see next point) and refuse traffic over HTTP
- Use [HSTS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security) to force the browser to use HTTPS in all subsequent requests without trying HTTP first even if the user types `http://*` in the address bar

Finally, there are mitigation steps that can be taken to lessen the impact of a stolen identifier :
- Do not rely solely on the session token for the most privileged actions : require a second identification method like re-typing a password or providing a one-time code (ex: Sudo mode in GitHub, or security codes when sending money in banking apps)
- Have a sane, easy and fast password change/reset method that will invalidate all existing sessions
- Require a second proof of ownership when trying to change credentials (for instance, prove the control of an email address or type the old password)
- Invalidate the session in case of strange behavior (ex: too many requests for a human, different IP address/user agent than usual, and so on). Be careful about false positives though as that will degrade the user experience.